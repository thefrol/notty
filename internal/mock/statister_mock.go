package mock

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i gitlab.com/thefrol/notty/internal/app/server.Statister -o ./internal/mock/statister_mock.go -n StatisterMock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.com/thefrol/notty/internal/dto"
)

// StatisterMock implements server.Statister
type StatisterMock struct {
	t minimock.Tester

	funcAll          func() (s1 dto.Statistics, err error)
	inspectFuncAll   func()
	afterAllCounter  uint64
	beforeAllCounter uint64
	AllMock          mStatisterMockAll

	funcFilter          func(s1 string, s2 string, s3 string) (s4 dto.Statistics, err error)
	inspectFuncFilter   func(s1 string, s2 string, s3 string)
	afterFilterCounter  uint64
	beforeFilterCounter uint64
	FilterMock          mStatisterMockFilter
}

// NewStatisterMock returns a mock for server.Statister
func NewStatisterMock(t minimock.Tester) *StatisterMock {
	m := &StatisterMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AllMock = mStatisterMockAll{mock: m}

	m.FilterMock = mStatisterMockFilter{mock: m}
	m.FilterMock.callArgs = []*StatisterMockFilterParams{}

	return m
}

type mStatisterMockAll struct {
	mock               *StatisterMock
	defaultExpectation *StatisterMockAllExpectation
	expectations       []*StatisterMockAllExpectation
}

// StatisterMockAllExpectation specifies expectation struct of the Statister.All
type StatisterMockAllExpectation struct {
	mock *StatisterMock

	results *StatisterMockAllResults
	Counter uint64
}

// StatisterMockAllResults contains results of the Statister.All
type StatisterMockAllResults struct {
	s1  dto.Statistics
	err error
}

// Expect sets up expected params for Statister.All
func (mmAll *mStatisterMockAll) Expect() *mStatisterMockAll {
	if mmAll.mock.funcAll != nil {
		mmAll.mock.t.Fatalf("StatisterMock.All mock is already set by Set")
	}

	if mmAll.defaultExpectation == nil {
		mmAll.defaultExpectation = &StatisterMockAllExpectation{}
	}

	return mmAll
}

// Inspect accepts an inspector function that has same arguments as the Statister.All
func (mmAll *mStatisterMockAll) Inspect(f func()) *mStatisterMockAll {
	if mmAll.mock.inspectFuncAll != nil {
		mmAll.mock.t.Fatalf("Inspect function is already set for StatisterMock.All")
	}

	mmAll.mock.inspectFuncAll = f

	return mmAll
}

// Return sets up results that will be returned by Statister.All
func (mmAll *mStatisterMockAll) Return(s1 dto.Statistics, err error) *StatisterMock {
	if mmAll.mock.funcAll != nil {
		mmAll.mock.t.Fatalf("StatisterMock.All mock is already set by Set")
	}

	if mmAll.defaultExpectation == nil {
		mmAll.defaultExpectation = &StatisterMockAllExpectation{mock: mmAll.mock}
	}
	mmAll.defaultExpectation.results = &StatisterMockAllResults{s1, err}
	return mmAll.mock
}

// Set uses given function f to mock the Statister.All method
func (mmAll *mStatisterMockAll) Set(f func() (s1 dto.Statistics, err error)) *StatisterMock {
	if mmAll.defaultExpectation != nil {
		mmAll.mock.t.Fatalf("Default expectation is already set for the Statister.All method")
	}

	if len(mmAll.expectations) > 0 {
		mmAll.mock.t.Fatalf("Some expectations are already set for the Statister.All method")
	}

	mmAll.mock.funcAll = f
	return mmAll.mock
}

// All implements server.Statister
func (mmAll *StatisterMock) All() (s1 dto.Statistics, err error) {
	mm_atomic.AddUint64(&mmAll.beforeAllCounter, 1)
	defer mm_atomic.AddUint64(&mmAll.afterAllCounter, 1)

	if mmAll.inspectFuncAll != nil {
		mmAll.inspectFuncAll()
	}

	if mmAll.AllMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAll.AllMock.defaultExpectation.Counter, 1)

		mm_results := mmAll.AllMock.defaultExpectation.results
		if mm_results == nil {
			mmAll.t.Fatal("No results are set for the StatisterMock.All")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmAll.funcAll != nil {
		return mmAll.funcAll()
	}
	mmAll.t.Fatalf("Unexpected call to StatisterMock.All.")
	return
}

// AllAfterCounter returns a count of finished StatisterMock.All invocations
func (mmAll *StatisterMock) AllAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAll.afterAllCounter)
}

// AllBeforeCounter returns a count of StatisterMock.All invocations
func (mmAll *StatisterMock) AllBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAll.beforeAllCounter)
}

// MinimockAllDone returns true if the count of the All invocations corresponds
// the number of defined expectations
func (m *StatisterMock) MinimockAllDone() bool {
	for _, e := range m.AllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAllCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAll != nil && mm_atomic.LoadUint64(&m.afterAllCounter) < 1 {
		return false
	}
	return true
}

// MinimockAllInspect logs each unmet expectation
func (m *StatisterMock) MinimockAllInspect() {
	for _, e := range m.AllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StatisterMock.All")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AllMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAllCounter) < 1 {
		m.t.Error("Expected call to StatisterMock.All")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAll != nil && mm_atomic.LoadUint64(&m.afterAllCounter) < 1 {
		m.t.Error("Expected call to StatisterMock.All")
	}
}

type mStatisterMockFilter struct {
	mock               *StatisterMock
	defaultExpectation *StatisterMockFilterExpectation
	expectations       []*StatisterMockFilterExpectation

	callArgs []*StatisterMockFilterParams
	mutex    sync.RWMutex
}

// StatisterMockFilterExpectation specifies expectation struct of the Statister.Filter
type StatisterMockFilterExpectation struct {
	mock    *StatisterMock
	params  *StatisterMockFilterParams
	results *StatisterMockFilterResults
	Counter uint64
}

// StatisterMockFilterParams contains parameters of the Statister.Filter
type StatisterMockFilterParams struct {
	s1 string
	s2 string
	s3 string
}

// StatisterMockFilterResults contains results of the Statister.Filter
type StatisterMockFilterResults struct {
	s4  dto.Statistics
	err error
}

// Expect sets up expected params for Statister.Filter
func (mmFilter *mStatisterMockFilter) Expect(s1 string, s2 string, s3 string) *mStatisterMockFilter {
	if mmFilter.mock.funcFilter != nil {
		mmFilter.mock.t.Fatalf("StatisterMock.Filter mock is already set by Set")
	}

	if mmFilter.defaultExpectation == nil {
		mmFilter.defaultExpectation = &StatisterMockFilterExpectation{}
	}

	mmFilter.defaultExpectation.params = &StatisterMockFilterParams{s1, s2, s3}
	for _, e := range mmFilter.expectations {
		if minimock.Equal(e.params, mmFilter.defaultExpectation.params) {
			mmFilter.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFilter.defaultExpectation.params)
		}
	}

	return mmFilter
}

// Inspect accepts an inspector function that has same arguments as the Statister.Filter
func (mmFilter *mStatisterMockFilter) Inspect(f func(s1 string, s2 string, s3 string)) *mStatisterMockFilter {
	if mmFilter.mock.inspectFuncFilter != nil {
		mmFilter.mock.t.Fatalf("Inspect function is already set for StatisterMock.Filter")
	}

	mmFilter.mock.inspectFuncFilter = f

	return mmFilter
}

// Return sets up results that will be returned by Statister.Filter
func (mmFilter *mStatisterMockFilter) Return(s4 dto.Statistics, err error) *StatisterMock {
	if mmFilter.mock.funcFilter != nil {
		mmFilter.mock.t.Fatalf("StatisterMock.Filter mock is already set by Set")
	}

	if mmFilter.defaultExpectation == nil {
		mmFilter.defaultExpectation = &StatisterMockFilterExpectation{mock: mmFilter.mock}
	}
	mmFilter.defaultExpectation.results = &StatisterMockFilterResults{s4, err}
	return mmFilter.mock
}

// Set uses given function f to mock the Statister.Filter method
func (mmFilter *mStatisterMockFilter) Set(f func(s1 string, s2 string, s3 string) (s4 dto.Statistics, err error)) *StatisterMock {
	if mmFilter.defaultExpectation != nil {
		mmFilter.mock.t.Fatalf("Default expectation is already set for the Statister.Filter method")
	}

	if len(mmFilter.expectations) > 0 {
		mmFilter.mock.t.Fatalf("Some expectations are already set for the Statister.Filter method")
	}

	mmFilter.mock.funcFilter = f
	return mmFilter.mock
}

// When sets expectation for the Statister.Filter which will trigger the result defined by the following
// Then helper
func (mmFilter *mStatisterMockFilter) When(s1 string, s2 string, s3 string) *StatisterMockFilterExpectation {
	if mmFilter.mock.funcFilter != nil {
		mmFilter.mock.t.Fatalf("StatisterMock.Filter mock is already set by Set")
	}

	expectation := &StatisterMockFilterExpectation{
		mock:   mmFilter.mock,
		params: &StatisterMockFilterParams{s1, s2, s3},
	}
	mmFilter.expectations = append(mmFilter.expectations, expectation)
	return expectation
}

// Then sets up Statister.Filter return parameters for the expectation previously defined by the When method
func (e *StatisterMockFilterExpectation) Then(s4 dto.Statistics, err error) *StatisterMock {
	e.results = &StatisterMockFilterResults{s4, err}
	return e.mock
}

// Filter implements server.Statister
func (mmFilter *StatisterMock) Filter(s1 string, s2 string, s3 string) (s4 dto.Statistics, err error) {
	mm_atomic.AddUint64(&mmFilter.beforeFilterCounter, 1)
	defer mm_atomic.AddUint64(&mmFilter.afterFilterCounter, 1)

	if mmFilter.inspectFuncFilter != nil {
		mmFilter.inspectFuncFilter(s1, s2, s3)
	}

	mm_params := &StatisterMockFilterParams{s1, s2, s3}

	// Record call args
	mmFilter.FilterMock.mutex.Lock()
	mmFilter.FilterMock.callArgs = append(mmFilter.FilterMock.callArgs, mm_params)
	mmFilter.FilterMock.mutex.Unlock()

	for _, e := range mmFilter.FilterMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s4, e.results.err
		}
	}

	if mmFilter.FilterMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFilter.FilterMock.defaultExpectation.Counter, 1)
		mm_want := mmFilter.FilterMock.defaultExpectation.params
		mm_got := StatisterMockFilterParams{s1, s2, s3}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFilter.t.Errorf("StatisterMock.Filter got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFilter.FilterMock.defaultExpectation.results
		if mm_results == nil {
			mmFilter.t.Fatal("No results are set for the StatisterMock.Filter")
		}
		return (*mm_results).s4, (*mm_results).err
	}
	if mmFilter.funcFilter != nil {
		return mmFilter.funcFilter(s1, s2, s3)
	}
	mmFilter.t.Fatalf("Unexpected call to StatisterMock.Filter. %v %v %v", s1, s2, s3)
	return
}

// FilterAfterCounter returns a count of finished StatisterMock.Filter invocations
func (mmFilter *StatisterMock) FilterAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFilter.afterFilterCounter)
}

// FilterBeforeCounter returns a count of StatisterMock.Filter invocations
func (mmFilter *StatisterMock) FilterBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFilter.beforeFilterCounter)
}

// Calls returns a list of arguments used in each call to StatisterMock.Filter.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFilter *mStatisterMockFilter) Calls() []*StatisterMockFilterParams {
	mmFilter.mutex.RLock()

	argCopy := make([]*StatisterMockFilterParams, len(mmFilter.callArgs))
	copy(argCopy, mmFilter.callArgs)

	mmFilter.mutex.RUnlock()

	return argCopy
}

// MinimockFilterDone returns true if the count of the Filter invocations corresponds
// the number of defined expectations
func (m *StatisterMock) MinimockFilterDone() bool {
	for _, e := range m.FilterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FilterMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFilterCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFilter != nil && mm_atomic.LoadUint64(&m.afterFilterCounter) < 1 {
		return false
	}
	return true
}

// MinimockFilterInspect logs each unmet expectation
func (m *StatisterMock) MinimockFilterInspect() {
	for _, e := range m.FilterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StatisterMock.Filter with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FilterMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFilterCounter) < 1 {
		if m.FilterMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StatisterMock.Filter")
		} else {
			m.t.Errorf("Expected call to StatisterMock.Filter with params: %#v", *m.FilterMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFilter != nil && mm_atomic.LoadUint64(&m.afterFilterCounter) < 1 {
		m.t.Error("Expected call to StatisterMock.Filter")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StatisterMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAllInspect()

		m.MinimockFilterInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StatisterMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StatisterMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAllDone() &&
		m.MinimockFilterDone()
}
