package mock

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i gitlab.com/thefrol/notty/internal/app.Customerere -o ./internal/mock/customerere_mock.go -n CustomerereMock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.com/thefrol/notty/internal/entity"
)

// CustomerereMock implements app.Customerere
type CustomerereMock struct {
	t minimock.Tester

	funcCreate          func(c1 entity.Customer) (c2 entity.Customer, err error)
	inspectFuncCreate   func(c1 entity.Customer)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mCustomerereMockCreate

	funcDelete          func(s1 string) (err error)
	inspectFuncDelete   func(s1 string)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mCustomerereMockDelete

	funcGet          func(s1 string) (c1 entity.Customer, err error)
	inspectFuncGet   func(s1 string)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mCustomerereMockGet

	funcUpdate          func(c1 entity.Customer) (c2 entity.Customer, err error)
	inspectFuncUpdate   func(c1 entity.Customer)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mCustomerereMockUpdate
}

// NewCustomerereMock returns a mock for app.Customerere
func NewCustomerereMock(t minimock.Tester) *CustomerereMock {
	m := &CustomerereMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mCustomerereMockCreate{mock: m}
	m.CreateMock.callArgs = []*CustomerereMockCreateParams{}

	m.DeleteMock = mCustomerereMockDelete{mock: m}
	m.DeleteMock.callArgs = []*CustomerereMockDeleteParams{}

	m.GetMock = mCustomerereMockGet{mock: m}
	m.GetMock.callArgs = []*CustomerereMockGetParams{}

	m.UpdateMock = mCustomerereMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*CustomerereMockUpdateParams{}

	return m
}

type mCustomerereMockCreate struct {
	mock               *CustomerereMock
	defaultExpectation *CustomerereMockCreateExpectation
	expectations       []*CustomerereMockCreateExpectation

	callArgs []*CustomerereMockCreateParams
	mutex    sync.RWMutex
}

// CustomerereMockCreateExpectation specifies expectation struct of the Customerere.Create
type CustomerereMockCreateExpectation struct {
	mock    *CustomerereMock
	params  *CustomerereMockCreateParams
	results *CustomerereMockCreateResults
	Counter uint64
}

// CustomerereMockCreateParams contains parameters of the Customerere.Create
type CustomerereMockCreateParams struct {
	c1 entity.Customer
}

// CustomerereMockCreateResults contains results of the Customerere.Create
type CustomerereMockCreateResults struct {
	c2  entity.Customer
	err error
}

// Expect sets up expected params for Customerere.Create
func (mmCreate *mCustomerereMockCreate) Expect(c1 entity.Customer) *mCustomerereMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("CustomerereMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &CustomerereMockCreateExpectation{}
	}

	mmCreate.defaultExpectation.params = &CustomerereMockCreateParams{c1}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the Customerere.Create
func (mmCreate *mCustomerereMockCreate) Inspect(f func(c1 entity.Customer)) *mCustomerereMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for CustomerereMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by Customerere.Create
func (mmCreate *mCustomerereMockCreate) Return(c2 entity.Customer, err error) *CustomerereMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("CustomerereMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &CustomerereMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &CustomerereMockCreateResults{c2, err}
	return mmCreate.mock
}

// Set uses given function f to mock the Customerere.Create method
func (mmCreate *mCustomerereMockCreate) Set(f func(c1 entity.Customer) (c2 entity.Customer, err error)) *CustomerereMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the Customerere.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the Customerere.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the Customerere.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mCustomerereMockCreate) When(c1 entity.Customer) *CustomerereMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("CustomerereMock.Create mock is already set by Set")
	}

	expectation := &CustomerereMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &CustomerereMockCreateParams{c1},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up Customerere.Create return parameters for the expectation previously defined by the When method
func (e *CustomerereMockCreateExpectation) Then(c2 entity.Customer, err error) *CustomerereMock {
	e.results = &CustomerereMockCreateResults{c2, err}
	return e.mock
}

// Create implements app.Customerere
func (mmCreate *CustomerereMock) Create(c1 entity.Customer) (c2 entity.Customer, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(c1)
	}

	mm_params := &CustomerereMockCreateParams{c1}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_got := CustomerereMockCreateParams{c1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("CustomerereMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the CustomerereMock.Create")
		}
		return (*mm_results).c2, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(c1)
	}
	mmCreate.t.Fatalf("Unexpected call to CustomerereMock.Create. %v", c1)
	return
}

// CreateAfterCounter returns a count of finished CustomerereMock.Create invocations
func (mmCreate *CustomerereMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of CustomerereMock.Create invocations
func (mmCreate *CustomerereMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to CustomerereMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mCustomerereMockCreate) Calls() []*CustomerereMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*CustomerereMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *CustomerereMock) MinimockCreateDone() bool {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateInspect logs each unmet expectation
func (m *CustomerereMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CustomerereMock.Create with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CustomerereMock.Create")
		} else {
			m.t.Errorf("Expected call to CustomerereMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		m.t.Error("Expected call to CustomerereMock.Create")
	}
}

type mCustomerereMockDelete struct {
	mock               *CustomerereMock
	defaultExpectation *CustomerereMockDeleteExpectation
	expectations       []*CustomerereMockDeleteExpectation

	callArgs []*CustomerereMockDeleteParams
	mutex    sync.RWMutex
}

// CustomerereMockDeleteExpectation specifies expectation struct of the Customerere.Delete
type CustomerereMockDeleteExpectation struct {
	mock    *CustomerereMock
	params  *CustomerereMockDeleteParams
	results *CustomerereMockDeleteResults
	Counter uint64
}

// CustomerereMockDeleteParams contains parameters of the Customerere.Delete
type CustomerereMockDeleteParams struct {
	s1 string
}

// CustomerereMockDeleteResults contains results of the Customerere.Delete
type CustomerereMockDeleteResults struct {
	err error
}

// Expect sets up expected params for Customerere.Delete
func (mmDelete *mCustomerereMockDelete) Expect(s1 string) *mCustomerereMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("CustomerereMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &CustomerereMockDeleteExpectation{}
	}

	mmDelete.defaultExpectation.params = &CustomerereMockDeleteParams{s1}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the Customerere.Delete
func (mmDelete *mCustomerereMockDelete) Inspect(f func(s1 string)) *mCustomerereMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for CustomerereMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by Customerere.Delete
func (mmDelete *mCustomerereMockDelete) Return(err error) *CustomerereMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("CustomerereMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &CustomerereMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &CustomerereMockDeleteResults{err}
	return mmDelete.mock
}

// Set uses given function f to mock the Customerere.Delete method
func (mmDelete *mCustomerereMockDelete) Set(f func(s1 string) (err error)) *CustomerereMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the Customerere.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the Customerere.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the Customerere.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mCustomerereMockDelete) When(s1 string) *CustomerereMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("CustomerereMock.Delete mock is already set by Set")
	}

	expectation := &CustomerereMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &CustomerereMockDeleteParams{s1},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up Customerere.Delete return parameters for the expectation previously defined by the When method
func (e *CustomerereMockDeleteExpectation) Then(err error) *CustomerereMock {
	e.results = &CustomerereMockDeleteResults{err}
	return e.mock
}

// Delete implements app.Customerere
func (mmDelete *CustomerereMock) Delete(s1 string) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(s1)
	}

	mm_params := &CustomerereMockDeleteParams{s1}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_got := CustomerereMockDeleteParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("CustomerereMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the CustomerereMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(s1)
	}
	mmDelete.t.Fatalf("Unexpected call to CustomerereMock.Delete. %v", s1)
	return
}

// DeleteAfterCounter returns a count of finished CustomerereMock.Delete invocations
func (mmDelete *CustomerereMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of CustomerereMock.Delete invocations
func (mmDelete *CustomerereMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to CustomerereMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mCustomerereMockDelete) Calls() []*CustomerereMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*CustomerereMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *CustomerereMock) MinimockDeleteDone() bool {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteInspect logs each unmet expectation
func (m *CustomerereMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CustomerereMock.Delete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CustomerereMock.Delete")
		} else {
			m.t.Errorf("Expected call to CustomerereMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		m.t.Error("Expected call to CustomerereMock.Delete")
	}
}

type mCustomerereMockGet struct {
	mock               *CustomerereMock
	defaultExpectation *CustomerereMockGetExpectation
	expectations       []*CustomerereMockGetExpectation

	callArgs []*CustomerereMockGetParams
	mutex    sync.RWMutex
}

// CustomerereMockGetExpectation specifies expectation struct of the Customerere.Get
type CustomerereMockGetExpectation struct {
	mock    *CustomerereMock
	params  *CustomerereMockGetParams
	results *CustomerereMockGetResults
	Counter uint64
}

// CustomerereMockGetParams contains parameters of the Customerere.Get
type CustomerereMockGetParams struct {
	s1 string
}

// CustomerereMockGetResults contains results of the Customerere.Get
type CustomerereMockGetResults struct {
	c1  entity.Customer
	err error
}

// Expect sets up expected params for Customerere.Get
func (mmGet *mCustomerereMockGet) Expect(s1 string) *mCustomerereMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("CustomerereMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &CustomerereMockGetExpectation{}
	}

	mmGet.defaultExpectation.params = &CustomerereMockGetParams{s1}
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the Customerere.Get
func (mmGet *mCustomerereMockGet) Inspect(f func(s1 string)) *mCustomerereMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for CustomerereMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by Customerere.Get
func (mmGet *mCustomerereMockGet) Return(c1 entity.Customer, err error) *CustomerereMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("CustomerereMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &CustomerereMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &CustomerereMockGetResults{c1, err}
	return mmGet.mock
}

// Set uses given function f to mock the Customerere.Get method
func (mmGet *mCustomerereMockGet) Set(f func(s1 string) (c1 entity.Customer, err error)) *CustomerereMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the Customerere.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the Customerere.Get method")
	}

	mmGet.mock.funcGet = f
	return mmGet.mock
}

// When sets expectation for the Customerere.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mCustomerereMockGet) When(s1 string) *CustomerereMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("CustomerereMock.Get mock is already set by Set")
	}

	expectation := &CustomerereMockGetExpectation{
		mock:   mmGet.mock,
		params: &CustomerereMockGetParams{s1},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up Customerere.Get return parameters for the expectation previously defined by the When method
func (e *CustomerereMockGetExpectation) Then(c1 entity.Customer, err error) *CustomerereMock {
	e.results = &CustomerereMockGetResults{c1, err}
	return e.mock
}

// Get implements app.Customerere
func (mmGet *CustomerereMock) Get(s1 string) (c1 entity.Customer, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(s1)
	}

	mm_params := &CustomerereMockGetParams{s1}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_got := CustomerereMockGetParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("CustomerereMock.Get got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the CustomerereMock.Get")
		}
		return (*mm_results).c1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(s1)
	}
	mmGet.t.Fatalf("Unexpected call to CustomerereMock.Get. %v", s1)
	return
}

// GetAfterCounter returns a count of finished CustomerereMock.Get invocations
func (mmGet *CustomerereMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of CustomerereMock.Get invocations
func (mmGet *CustomerereMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to CustomerereMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mCustomerereMockGet) Calls() []*CustomerereMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*CustomerereMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *CustomerereMock) MinimockGetDone() bool {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetInspect logs each unmet expectation
func (m *CustomerereMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CustomerereMock.Get with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CustomerereMock.Get")
		} else {
			m.t.Errorf("Expected call to CustomerereMock.Get with params: %#v", *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		m.t.Error("Expected call to CustomerereMock.Get")
	}
}

type mCustomerereMockUpdate struct {
	mock               *CustomerereMock
	defaultExpectation *CustomerereMockUpdateExpectation
	expectations       []*CustomerereMockUpdateExpectation

	callArgs []*CustomerereMockUpdateParams
	mutex    sync.RWMutex
}

// CustomerereMockUpdateExpectation specifies expectation struct of the Customerere.Update
type CustomerereMockUpdateExpectation struct {
	mock    *CustomerereMock
	params  *CustomerereMockUpdateParams
	results *CustomerereMockUpdateResults
	Counter uint64
}

// CustomerereMockUpdateParams contains parameters of the Customerere.Update
type CustomerereMockUpdateParams struct {
	c1 entity.Customer
}

// CustomerereMockUpdateResults contains results of the Customerere.Update
type CustomerereMockUpdateResults struct {
	c2  entity.Customer
	err error
}

// Expect sets up expected params for Customerere.Update
func (mmUpdate *mCustomerereMockUpdate) Expect(c1 entity.Customer) *mCustomerereMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("CustomerereMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &CustomerereMockUpdateExpectation{}
	}

	mmUpdate.defaultExpectation.params = &CustomerereMockUpdateParams{c1}
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the Customerere.Update
func (mmUpdate *mCustomerereMockUpdate) Inspect(f func(c1 entity.Customer)) *mCustomerereMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for CustomerereMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by Customerere.Update
func (mmUpdate *mCustomerereMockUpdate) Return(c2 entity.Customer, err error) *CustomerereMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("CustomerereMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &CustomerereMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &CustomerereMockUpdateResults{c2, err}
	return mmUpdate.mock
}

// Set uses given function f to mock the Customerere.Update method
func (mmUpdate *mCustomerereMockUpdate) Set(f func(c1 entity.Customer) (c2 entity.Customer, err error)) *CustomerereMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the Customerere.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the Customerere.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	return mmUpdate.mock
}

// When sets expectation for the Customerere.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mCustomerereMockUpdate) When(c1 entity.Customer) *CustomerereMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("CustomerereMock.Update mock is already set by Set")
	}

	expectation := &CustomerereMockUpdateExpectation{
		mock:   mmUpdate.mock,
		params: &CustomerereMockUpdateParams{c1},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up Customerere.Update return parameters for the expectation previously defined by the When method
func (e *CustomerereMockUpdateExpectation) Then(c2 entity.Customer, err error) *CustomerereMock {
	e.results = &CustomerereMockUpdateResults{c2, err}
	return e.mock
}

// Update implements app.Customerere
func (mmUpdate *CustomerereMock) Update(c1 entity.Customer) (c2 entity.Customer, err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(c1)
	}

	mm_params := &CustomerereMockUpdateParams{c1}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2, e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_got := CustomerereMockUpdateParams{c1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("CustomerereMock.Update got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the CustomerereMock.Update")
		}
		return (*mm_results).c2, (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(c1)
	}
	mmUpdate.t.Fatalf("Unexpected call to CustomerereMock.Update. %v", c1)
	return
}

// UpdateAfterCounter returns a count of finished CustomerereMock.Update invocations
func (mmUpdate *CustomerereMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of CustomerereMock.Update invocations
func (mmUpdate *CustomerereMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to CustomerereMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mCustomerereMockUpdate) Calls() []*CustomerereMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*CustomerereMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *CustomerereMock) MinimockUpdateDone() bool {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateInspect logs each unmet expectation
func (m *CustomerereMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CustomerereMock.Update with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CustomerereMock.Update")
		} else {
			m.t.Errorf("Expected call to CustomerereMock.Update with params: %#v", *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		m.t.Error("Expected call to CustomerereMock.Update")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CustomerereMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateInspect()

		m.MinimockDeleteInspect()

		m.MinimockGetInspect()

		m.MinimockUpdateInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CustomerereMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CustomerereMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetDone() &&
		m.MinimockUpdateDone()
}
