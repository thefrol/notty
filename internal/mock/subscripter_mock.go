package mock

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i gitlab.com/thefrol/notty/internal/app.Subscripter -o ./internal/mock/subscripter_mock.go -n SubscripterMock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.com/thefrol/notty/internal/entity"
)

// SubscripterMock implements app.Subscripter
type SubscripterMock struct {
	t minimock.Tester

	funcCreate          func(s1 entity.Subscription) (s2 entity.Subscription, err error)
	inspectFuncCreate   func(s1 entity.Subscription)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mSubscripterMockCreate

	funcDelete          func(s1 string) (err error)
	inspectFuncDelete   func(s1 string)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mSubscripterMockDelete

	funcGet          func(s1 string) (s2 entity.Subscription, err error)
	inspectFuncGet   func(s1 string)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mSubscripterMockGet

	funcUpdate          func(s1 entity.Subscription) (s2 entity.Subscription, err error)
	inspectFuncUpdate   func(s1 entity.Subscription)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mSubscripterMockUpdate
}

// NewSubscripterMock returns a mock for app.Subscripter
func NewSubscripterMock(t minimock.Tester) *SubscripterMock {
	m := &SubscripterMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mSubscripterMockCreate{mock: m}
	m.CreateMock.callArgs = []*SubscripterMockCreateParams{}

	m.DeleteMock = mSubscripterMockDelete{mock: m}
	m.DeleteMock.callArgs = []*SubscripterMockDeleteParams{}

	m.GetMock = mSubscripterMockGet{mock: m}
	m.GetMock.callArgs = []*SubscripterMockGetParams{}

	m.UpdateMock = mSubscripterMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*SubscripterMockUpdateParams{}

	return m
}

type mSubscripterMockCreate struct {
	mock               *SubscripterMock
	defaultExpectation *SubscripterMockCreateExpectation
	expectations       []*SubscripterMockCreateExpectation

	callArgs []*SubscripterMockCreateParams
	mutex    sync.RWMutex
}

// SubscripterMockCreateExpectation specifies expectation struct of the Subscripter.Create
type SubscripterMockCreateExpectation struct {
	mock    *SubscripterMock
	params  *SubscripterMockCreateParams
	results *SubscripterMockCreateResults
	Counter uint64
}

// SubscripterMockCreateParams contains parameters of the Subscripter.Create
type SubscripterMockCreateParams struct {
	s1 entity.Subscription
}

// SubscripterMockCreateResults contains results of the Subscripter.Create
type SubscripterMockCreateResults struct {
	s2  entity.Subscription
	err error
}

// Expect sets up expected params for Subscripter.Create
func (mmCreate *mSubscripterMockCreate) Expect(s1 entity.Subscription) *mSubscripterMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("SubscripterMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &SubscripterMockCreateExpectation{}
	}

	mmCreate.defaultExpectation.params = &SubscripterMockCreateParams{s1}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the Subscripter.Create
func (mmCreate *mSubscripterMockCreate) Inspect(f func(s1 entity.Subscription)) *mSubscripterMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for SubscripterMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by Subscripter.Create
func (mmCreate *mSubscripterMockCreate) Return(s2 entity.Subscription, err error) *SubscripterMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("SubscripterMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &SubscripterMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &SubscripterMockCreateResults{s2, err}
	return mmCreate.mock
}

// Set uses given function f to mock the Subscripter.Create method
func (mmCreate *mSubscripterMockCreate) Set(f func(s1 entity.Subscription) (s2 entity.Subscription, err error)) *SubscripterMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the Subscripter.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the Subscripter.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the Subscripter.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mSubscripterMockCreate) When(s1 entity.Subscription) *SubscripterMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("SubscripterMock.Create mock is already set by Set")
	}

	expectation := &SubscripterMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &SubscripterMockCreateParams{s1},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up Subscripter.Create return parameters for the expectation previously defined by the When method
func (e *SubscripterMockCreateExpectation) Then(s2 entity.Subscription, err error) *SubscripterMock {
	e.results = &SubscripterMockCreateResults{s2, err}
	return e.mock
}

// Create implements app.Subscripter
func (mmCreate *SubscripterMock) Create(s1 entity.Subscription) (s2 entity.Subscription, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(s1)
	}

	mm_params := &SubscripterMockCreateParams{s1}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s2, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_got := SubscripterMockCreateParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("SubscripterMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the SubscripterMock.Create")
		}
		return (*mm_results).s2, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(s1)
	}
	mmCreate.t.Fatalf("Unexpected call to SubscripterMock.Create. %v", s1)
	return
}

// CreateAfterCounter returns a count of finished SubscripterMock.Create invocations
func (mmCreate *SubscripterMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of SubscripterMock.Create invocations
func (mmCreate *SubscripterMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to SubscripterMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mSubscripterMockCreate) Calls() []*SubscripterMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*SubscripterMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *SubscripterMock) MinimockCreateDone() bool {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateInspect logs each unmet expectation
func (m *SubscripterMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SubscripterMock.Create with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SubscripterMock.Create")
		} else {
			m.t.Errorf("Expected call to SubscripterMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		m.t.Error("Expected call to SubscripterMock.Create")
	}
}

type mSubscripterMockDelete struct {
	mock               *SubscripterMock
	defaultExpectation *SubscripterMockDeleteExpectation
	expectations       []*SubscripterMockDeleteExpectation

	callArgs []*SubscripterMockDeleteParams
	mutex    sync.RWMutex
}

// SubscripterMockDeleteExpectation specifies expectation struct of the Subscripter.Delete
type SubscripterMockDeleteExpectation struct {
	mock    *SubscripterMock
	params  *SubscripterMockDeleteParams
	results *SubscripterMockDeleteResults
	Counter uint64
}

// SubscripterMockDeleteParams contains parameters of the Subscripter.Delete
type SubscripterMockDeleteParams struct {
	s1 string
}

// SubscripterMockDeleteResults contains results of the Subscripter.Delete
type SubscripterMockDeleteResults struct {
	err error
}

// Expect sets up expected params for Subscripter.Delete
func (mmDelete *mSubscripterMockDelete) Expect(s1 string) *mSubscripterMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("SubscripterMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &SubscripterMockDeleteExpectation{}
	}

	mmDelete.defaultExpectation.params = &SubscripterMockDeleteParams{s1}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the Subscripter.Delete
func (mmDelete *mSubscripterMockDelete) Inspect(f func(s1 string)) *mSubscripterMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for SubscripterMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by Subscripter.Delete
func (mmDelete *mSubscripterMockDelete) Return(err error) *SubscripterMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("SubscripterMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &SubscripterMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &SubscripterMockDeleteResults{err}
	return mmDelete.mock
}

// Set uses given function f to mock the Subscripter.Delete method
func (mmDelete *mSubscripterMockDelete) Set(f func(s1 string) (err error)) *SubscripterMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the Subscripter.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the Subscripter.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the Subscripter.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mSubscripterMockDelete) When(s1 string) *SubscripterMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("SubscripterMock.Delete mock is already set by Set")
	}

	expectation := &SubscripterMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &SubscripterMockDeleteParams{s1},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up Subscripter.Delete return parameters for the expectation previously defined by the When method
func (e *SubscripterMockDeleteExpectation) Then(err error) *SubscripterMock {
	e.results = &SubscripterMockDeleteResults{err}
	return e.mock
}

// Delete implements app.Subscripter
func (mmDelete *SubscripterMock) Delete(s1 string) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(s1)
	}

	mm_params := &SubscripterMockDeleteParams{s1}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_got := SubscripterMockDeleteParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("SubscripterMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the SubscripterMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(s1)
	}
	mmDelete.t.Fatalf("Unexpected call to SubscripterMock.Delete. %v", s1)
	return
}

// DeleteAfterCounter returns a count of finished SubscripterMock.Delete invocations
func (mmDelete *SubscripterMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of SubscripterMock.Delete invocations
func (mmDelete *SubscripterMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to SubscripterMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mSubscripterMockDelete) Calls() []*SubscripterMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*SubscripterMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *SubscripterMock) MinimockDeleteDone() bool {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteInspect logs each unmet expectation
func (m *SubscripterMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SubscripterMock.Delete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SubscripterMock.Delete")
		} else {
			m.t.Errorf("Expected call to SubscripterMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		m.t.Error("Expected call to SubscripterMock.Delete")
	}
}

type mSubscripterMockGet struct {
	mock               *SubscripterMock
	defaultExpectation *SubscripterMockGetExpectation
	expectations       []*SubscripterMockGetExpectation

	callArgs []*SubscripterMockGetParams
	mutex    sync.RWMutex
}

// SubscripterMockGetExpectation specifies expectation struct of the Subscripter.Get
type SubscripterMockGetExpectation struct {
	mock    *SubscripterMock
	params  *SubscripterMockGetParams
	results *SubscripterMockGetResults
	Counter uint64
}

// SubscripterMockGetParams contains parameters of the Subscripter.Get
type SubscripterMockGetParams struct {
	s1 string
}

// SubscripterMockGetResults contains results of the Subscripter.Get
type SubscripterMockGetResults struct {
	s2  entity.Subscription
	err error
}

// Expect sets up expected params for Subscripter.Get
func (mmGet *mSubscripterMockGet) Expect(s1 string) *mSubscripterMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("SubscripterMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &SubscripterMockGetExpectation{}
	}

	mmGet.defaultExpectation.params = &SubscripterMockGetParams{s1}
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the Subscripter.Get
func (mmGet *mSubscripterMockGet) Inspect(f func(s1 string)) *mSubscripterMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for SubscripterMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by Subscripter.Get
func (mmGet *mSubscripterMockGet) Return(s2 entity.Subscription, err error) *SubscripterMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("SubscripterMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &SubscripterMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &SubscripterMockGetResults{s2, err}
	return mmGet.mock
}

// Set uses given function f to mock the Subscripter.Get method
func (mmGet *mSubscripterMockGet) Set(f func(s1 string) (s2 entity.Subscription, err error)) *SubscripterMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the Subscripter.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the Subscripter.Get method")
	}

	mmGet.mock.funcGet = f
	return mmGet.mock
}

// When sets expectation for the Subscripter.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mSubscripterMockGet) When(s1 string) *SubscripterMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("SubscripterMock.Get mock is already set by Set")
	}

	expectation := &SubscripterMockGetExpectation{
		mock:   mmGet.mock,
		params: &SubscripterMockGetParams{s1},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up Subscripter.Get return parameters for the expectation previously defined by the When method
func (e *SubscripterMockGetExpectation) Then(s2 entity.Subscription, err error) *SubscripterMock {
	e.results = &SubscripterMockGetResults{s2, err}
	return e.mock
}

// Get implements app.Subscripter
func (mmGet *SubscripterMock) Get(s1 string) (s2 entity.Subscription, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(s1)
	}

	mm_params := &SubscripterMockGetParams{s1}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s2, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_got := SubscripterMockGetParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("SubscripterMock.Get got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the SubscripterMock.Get")
		}
		return (*mm_results).s2, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(s1)
	}
	mmGet.t.Fatalf("Unexpected call to SubscripterMock.Get. %v", s1)
	return
}

// GetAfterCounter returns a count of finished SubscripterMock.Get invocations
func (mmGet *SubscripterMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of SubscripterMock.Get invocations
func (mmGet *SubscripterMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to SubscripterMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mSubscripterMockGet) Calls() []*SubscripterMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*SubscripterMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *SubscripterMock) MinimockGetDone() bool {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetInspect logs each unmet expectation
func (m *SubscripterMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SubscripterMock.Get with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SubscripterMock.Get")
		} else {
			m.t.Errorf("Expected call to SubscripterMock.Get with params: %#v", *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		m.t.Error("Expected call to SubscripterMock.Get")
	}
}

type mSubscripterMockUpdate struct {
	mock               *SubscripterMock
	defaultExpectation *SubscripterMockUpdateExpectation
	expectations       []*SubscripterMockUpdateExpectation

	callArgs []*SubscripterMockUpdateParams
	mutex    sync.RWMutex
}

// SubscripterMockUpdateExpectation specifies expectation struct of the Subscripter.Update
type SubscripterMockUpdateExpectation struct {
	mock    *SubscripterMock
	params  *SubscripterMockUpdateParams
	results *SubscripterMockUpdateResults
	Counter uint64
}

// SubscripterMockUpdateParams contains parameters of the Subscripter.Update
type SubscripterMockUpdateParams struct {
	s1 entity.Subscription
}

// SubscripterMockUpdateResults contains results of the Subscripter.Update
type SubscripterMockUpdateResults struct {
	s2  entity.Subscription
	err error
}

// Expect sets up expected params for Subscripter.Update
func (mmUpdate *mSubscripterMockUpdate) Expect(s1 entity.Subscription) *mSubscripterMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("SubscripterMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &SubscripterMockUpdateExpectation{}
	}

	mmUpdate.defaultExpectation.params = &SubscripterMockUpdateParams{s1}
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the Subscripter.Update
func (mmUpdate *mSubscripterMockUpdate) Inspect(f func(s1 entity.Subscription)) *mSubscripterMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for SubscripterMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by Subscripter.Update
func (mmUpdate *mSubscripterMockUpdate) Return(s2 entity.Subscription, err error) *SubscripterMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("SubscripterMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &SubscripterMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &SubscripterMockUpdateResults{s2, err}
	return mmUpdate.mock
}

// Set uses given function f to mock the Subscripter.Update method
func (mmUpdate *mSubscripterMockUpdate) Set(f func(s1 entity.Subscription) (s2 entity.Subscription, err error)) *SubscripterMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the Subscripter.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the Subscripter.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	return mmUpdate.mock
}

// When sets expectation for the Subscripter.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mSubscripterMockUpdate) When(s1 entity.Subscription) *SubscripterMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("SubscripterMock.Update mock is already set by Set")
	}

	expectation := &SubscripterMockUpdateExpectation{
		mock:   mmUpdate.mock,
		params: &SubscripterMockUpdateParams{s1},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up Subscripter.Update return parameters for the expectation previously defined by the When method
func (e *SubscripterMockUpdateExpectation) Then(s2 entity.Subscription, err error) *SubscripterMock {
	e.results = &SubscripterMockUpdateResults{s2, err}
	return e.mock
}

// Update implements app.Subscripter
func (mmUpdate *SubscripterMock) Update(s1 entity.Subscription) (s2 entity.Subscription, err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(s1)
	}

	mm_params := &SubscripterMockUpdateParams{s1}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s2, e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_got := SubscripterMockUpdateParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("SubscripterMock.Update got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the SubscripterMock.Update")
		}
		return (*mm_results).s2, (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(s1)
	}
	mmUpdate.t.Fatalf("Unexpected call to SubscripterMock.Update. %v", s1)
	return
}

// UpdateAfterCounter returns a count of finished SubscripterMock.Update invocations
func (mmUpdate *SubscripterMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of SubscripterMock.Update invocations
func (mmUpdate *SubscripterMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to SubscripterMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mSubscripterMockUpdate) Calls() []*SubscripterMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*SubscripterMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *SubscripterMock) MinimockUpdateDone() bool {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateInspect logs each unmet expectation
func (m *SubscripterMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SubscripterMock.Update with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SubscripterMock.Update")
		} else {
			m.t.Errorf("Expected call to SubscripterMock.Update with params: %#v", *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		m.t.Error("Expected call to SubscripterMock.Update")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SubscripterMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateInspect()

		m.MinimockDeleteInspect()

		m.MinimockGetInspect()

		m.MinimockUpdateInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SubscripterMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SubscripterMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetDone() &&
		m.MinimockUpdateDone()
}
