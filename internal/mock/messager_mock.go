package mock

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i gitlab.com/thefrol/notty/internal/app.Messager -o ./internal/mock/messager_mock.go -n MessagerMock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.com/thefrol/notty/internal/entity"
)

// MessagerMock implements app.Messager
type MessagerMock struct {
	t minimock.Tester

	funcLockedSpawn          func(n int, status string) (ma1 []entity.Message, err error)
	inspectFuncLockedSpawn   func(n int, status string)
	afterLockedSpawnCounter  uint64
	beforeLockedSpawnCounter uint64
	LockedSpawnMock          mMessagerMockLockedSpawn

	funcReserveFromStatus          func(n int, status string) (ma1 []entity.Message, err error)
	inspectFuncReserveFromStatus   func(n int, status string)
	afterReserveFromStatusCounter  uint64
	beforeReserveFromStatusCounter uint64
	ReserveFromStatusMock          mMessagerMockReserveFromStatus

	funcUpdate          func(m1 entity.Message) (m2 entity.Message, err error)
	inspectFuncUpdate   func(m1 entity.Message)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mMessagerMockUpdate
}

// NewMessagerMock returns a mock for app.Messager
func NewMessagerMock(t minimock.Tester) *MessagerMock {
	m := &MessagerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.LockedSpawnMock = mMessagerMockLockedSpawn{mock: m}
	m.LockedSpawnMock.callArgs = []*MessagerMockLockedSpawnParams{}

	m.ReserveFromStatusMock = mMessagerMockReserveFromStatus{mock: m}
	m.ReserveFromStatusMock.callArgs = []*MessagerMockReserveFromStatusParams{}

	m.UpdateMock = mMessagerMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*MessagerMockUpdateParams{}

	return m
}

type mMessagerMockLockedSpawn struct {
	mock               *MessagerMock
	defaultExpectation *MessagerMockLockedSpawnExpectation
	expectations       []*MessagerMockLockedSpawnExpectation

	callArgs []*MessagerMockLockedSpawnParams
	mutex    sync.RWMutex
}

// MessagerMockLockedSpawnExpectation specifies expectation struct of the Messager.LockedSpawn
type MessagerMockLockedSpawnExpectation struct {
	mock    *MessagerMock
	params  *MessagerMockLockedSpawnParams
	results *MessagerMockLockedSpawnResults
	Counter uint64
}

// MessagerMockLockedSpawnParams contains parameters of the Messager.LockedSpawn
type MessagerMockLockedSpawnParams struct {
	n      int
	status string
}

// MessagerMockLockedSpawnResults contains results of the Messager.LockedSpawn
type MessagerMockLockedSpawnResults struct {
	ma1 []entity.Message
	err error
}

// Expect sets up expected params for Messager.LockedSpawn
func (mmLockedSpawn *mMessagerMockLockedSpawn) Expect(n int, status string) *mMessagerMockLockedSpawn {
	if mmLockedSpawn.mock.funcLockedSpawn != nil {
		mmLockedSpawn.mock.t.Fatalf("MessagerMock.LockedSpawn mock is already set by Set")
	}

	if mmLockedSpawn.defaultExpectation == nil {
		mmLockedSpawn.defaultExpectation = &MessagerMockLockedSpawnExpectation{}
	}

	mmLockedSpawn.defaultExpectation.params = &MessagerMockLockedSpawnParams{n, status}
	for _, e := range mmLockedSpawn.expectations {
		if minimock.Equal(e.params, mmLockedSpawn.defaultExpectation.params) {
			mmLockedSpawn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLockedSpawn.defaultExpectation.params)
		}
	}

	return mmLockedSpawn
}

// Inspect accepts an inspector function that has same arguments as the Messager.LockedSpawn
func (mmLockedSpawn *mMessagerMockLockedSpawn) Inspect(f func(n int, status string)) *mMessagerMockLockedSpawn {
	if mmLockedSpawn.mock.inspectFuncLockedSpawn != nil {
		mmLockedSpawn.mock.t.Fatalf("Inspect function is already set for MessagerMock.LockedSpawn")
	}

	mmLockedSpawn.mock.inspectFuncLockedSpawn = f

	return mmLockedSpawn
}

// Return sets up results that will be returned by Messager.LockedSpawn
func (mmLockedSpawn *mMessagerMockLockedSpawn) Return(ma1 []entity.Message, err error) *MessagerMock {
	if mmLockedSpawn.mock.funcLockedSpawn != nil {
		mmLockedSpawn.mock.t.Fatalf("MessagerMock.LockedSpawn mock is already set by Set")
	}

	if mmLockedSpawn.defaultExpectation == nil {
		mmLockedSpawn.defaultExpectation = &MessagerMockLockedSpawnExpectation{mock: mmLockedSpawn.mock}
	}
	mmLockedSpawn.defaultExpectation.results = &MessagerMockLockedSpawnResults{ma1, err}
	return mmLockedSpawn.mock
}

// Set uses given function f to mock the Messager.LockedSpawn method
func (mmLockedSpawn *mMessagerMockLockedSpawn) Set(f func(n int, status string) (ma1 []entity.Message, err error)) *MessagerMock {
	if mmLockedSpawn.defaultExpectation != nil {
		mmLockedSpawn.mock.t.Fatalf("Default expectation is already set for the Messager.LockedSpawn method")
	}

	if len(mmLockedSpawn.expectations) > 0 {
		mmLockedSpawn.mock.t.Fatalf("Some expectations are already set for the Messager.LockedSpawn method")
	}

	mmLockedSpawn.mock.funcLockedSpawn = f
	return mmLockedSpawn.mock
}

// When sets expectation for the Messager.LockedSpawn which will trigger the result defined by the following
// Then helper
func (mmLockedSpawn *mMessagerMockLockedSpawn) When(n int, status string) *MessagerMockLockedSpawnExpectation {
	if mmLockedSpawn.mock.funcLockedSpawn != nil {
		mmLockedSpawn.mock.t.Fatalf("MessagerMock.LockedSpawn mock is already set by Set")
	}

	expectation := &MessagerMockLockedSpawnExpectation{
		mock:   mmLockedSpawn.mock,
		params: &MessagerMockLockedSpawnParams{n, status},
	}
	mmLockedSpawn.expectations = append(mmLockedSpawn.expectations, expectation)
	return expectation
}

// Then sets up Messager.LockedSpawn return parameters for the expectation previously defined by the When method
func (e *MessagerMockLockedSpawnExpectation) Then(ma1 []entity.Message, err error) *MessagerMock {
	e.results = &MessagerMockLockedSpawnResults{ma1, err}
	return e.mock
}

// LockedSpawn implements app.Messager
func (mmLockedSpawn *MessagerMock) LockedSpawn(n int, status string) (ma1 []entity.Message, err error) {
	mm_atomic.AddUint64(&mmLockedSpawn.beforeLockedSpawnCounter, 1)
	defer mm_atomic.AddUint64(&mmLockedSpawn.afterLockedSpawnCounter, 1)

	if mmLockedSpawn.inspectFuncLockedSpawn != nil {
		mmLockedSpawn.inspectFuncLockedSpawn(n, status)
	}

	mm_params := &MessagerMockLockedSpawnParams{n, status}

	// Record call args
	mmLockedSpawn.LockedSpawnMock.mutex.Lock()
	mmLockedSpawn.LockedSpawnMock.callArgs = append(mmLockedSpawn.LockedSpawnMock.callArgs, mm_params)
	mmLockedSpawn.LockedSpawnMock.mutex.Unlock()

	for _, e := range mmLockedSpawn.LockedSpawnMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ma1, e.results.err
		}
	}

	if mmLockedSpawn.LockedSpawnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLockedSpawn.LockedSpawnMock.defaultExpectation.Counter, 1)
		mm_want := mmLockedSpawn.LockedSpawnMock.defaultExpectation.params
		mm_got := MessagerMockLockedSpawnParams{n, status}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLockedSpawn.t.Errorf("MessagerMock.LockedSpawn got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLockedSpawn.LockedSpawnMock.defaultExpectation.results
		if mm_results == nil {
			mmLockedSpawn.t.Fatal("No results are set for the MessagerMock.LockedSpawn")
		}
		return (*mm_results).ma1, (*mm_results).err
	}
	if mmLockedSpawn.funcLockedSpawn != nil {
		return mmLockedSpawn.funcLockedSpawn(n, status)
	}
	mmLockedSpawn.t.Fatalf("Unexpected call to MessagerMock.LockedSpawn. %v %v", n, status)
	return
}

// LockedSpawnAfterCounter returns a count of finished MessagerMock.LockedSpawn invocations
func (mmLockedSpawn *MessagerMock) LockedSpawnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLockedSpawn.afterLockedSpawnCounter)
}

// LockedSpawnBeforeCounter returns a count of MessagerMock.LockedSpawn invocations
func (mmLockedSpawn *MessagerMock) LockedSpawnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLockedSpawn.beforeLockedSpawnCounter)
}

// Calls returns a list of arguments used in each call to MessagerMock.LockedSpawn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLockedSpawn *mMessagerMockLockedSpawn) Calls() []*MessagerMockLockedSpawnParams {
	mmLockedSpawn.mutex.RLock()

	argCopy := make([]*MessagerMockLockedSpawnParams, len(mmLockedSpawn.callArgs))
	copy(argCopy, mmLockedSpawn.callArgs)

	mmLockedSpawn.mutex.RUnlock()

	return argCopy
}

// MinimockLockedSpawnDone returns true if the count of the LockedSpawn invocations corresponds
// the number of defined expectations
func (m *MessagerMock) MinimockLockedSpawnDone() bool {
	for _, e := range m.LockedSpawnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LockedSpawnMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLockedSpawnCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLockedSpawn != nil && mm_atomic.LoadUint64(&m.afterLockedSpawnCounter) < 1 {
		return false
	}
	return true
}

// MinimockLockedSpawnInspect logs each unmet expectation
func (m *MessagerMock) MinimockLockedSpawnInspect() {
	for _, e := range m.LockedSpawnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MessagerMock.LockedSpawn with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LockedSpawnMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLockedSpawnCounter) < 1 {
		if m.LockedSpawnMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MessagerMock.LockedSpawn")
		} else {
			m.t.Errorf("Expected call to MessagerMock.LockedSpawn with params: %#v", *m.LockedSpawnMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLockedSpawn != nil && mm_atomic.LoadUint64(&m.afterLockedSpawnCounter) < 1 {
		m.t.Error("Expected call to MessagerMock.LockedSpawn")
	}
}

type mMessagerMockReserveFromStatus struct {
	mock               *MessagerMock
	defaultExpectation *MessagerMockReserveFromStatusExpectation
	expectations       []*MessagerMockReserveFromStatusExpectation

	callArgs []*MessagerMockReserveFromStatusParams
	mutex    sync.RWMutex
}

// MessagerMockReserveFromStatusExpectation specifies expectation struct of the Messager.ReserveFromStatus
type MessagerMockReserveFromStatusExpectation struct {
	mock    *MessagerMock
	params  *MessagerMockReserveFromStatusParams
	results *MessagerMockReserveFromStatusResults
	Counter uint64
}

// MessagerMockReserveFromStatusParams contains parameters of the Messager.ReserveFromStatus
type MessagerMockReserveFromStatusParams struct {
	n      int
	status string
}

// MessagerMockReserveFromStatusResults contains results of the Messager.ReserveFromStatus
type MessagerMockReserveFromStatusResults struct {
	ma1 []entity.Message
	err error
}

// Expect sets up expected params for Messager.ReserveFromStatus
func (mmReserveFromStatus *mMessagerMockReserveFromStatus) Expect(n int, status string) *mMessagerMockReserveFromStatus {
	if mmReserveFromStatus.mock.funcReserveFromStatus != nil {
		mmReserveFromStatus.mock.t.Fatalf("MessagerMock.ReserveFromStatus mock is already set by Set")
	}

	if mmReserveFromStatus.defaultExpectation == nil {
		mmReserveFromStatus.defaultExpectation = &MessagerMockReserveFromStatusExpectation{}
	}

	mmReserveFromStatus.defaultExpectation.params = &MessagerMockReserveFromStatusParams{n, status}
	for _, e := range mmReserveFromStatus.expectations {
		if minimock.Equal(e.params, mmReserveFromStatus.defaultExpectation.params) {
			mmReserveFromStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReserveFromStatus.defaultExpectation.params)
		}
	}

	return mmReserveFromStatus
}

// Inspect accepts an inspector function that has same arguments as the Messager.ReserveFromStatus
func (mmReserveFromStatus *mMessagerMockReserveFromStatus) Inspect(f func(n int, status string)) *mMessagerMockReserveFromStatus {
	if mmReserveFromStatus.mock.inspectFuncReserveFromStatus != nil {
		mmReserveFromStatus.mock.t.Fatalf("Inspect function is already set for MessagerMock.ReserveFromStatus")
	}

	mmReserveFromStatus.mock.inspectFuncReserveFromStatus = f

	return mmReserveFromStatus
}

// Return sets up results that will be returned by Messager.ReserveFromStatus
func (mmReserveFromStatus *mMessagerMockReserveFromStatus) Return(ma1 []entity.Message, err error) *MessagerMock {
	if mmReserveFromStatus.mock.funcReserveFromStatus != nil {
		mmReserveFromStatus.mock.t.Fatalf("MessagerMock.ReserveFromStatus mock is already set by Set")
	}

	if mmReserveFromStatus.defaultExpectation == nil {
		mmReserveFromStatus.defaultExpectation = &MessagerMockReserveFromStatusExpectation{mock: mmReserveFromStatus.mock}
	}
	mmReserveFromStatus.defaultExpectation.results = &MessagerMockReserveFromStatusResults{ma1, err}
	return mmReserveFromStatus.mock
}

// Set uses given function f to mock the Messager.ReserveFromStatus method
func (mmReserveFromStatus *mMessagerMockReserveFromStatus) Set(f func(n int, status string) (ma1 []entity.Message, err error)) *MessagerMock {
	if mmReserveFromStatus.defaultExpectation != nil {
		mmReserveFromStatus.mock.t.Fatalf("Default expectation is already set for the Messager.ReserveFromStatus method")
	}

	if len(mmReserveFromStatus.expectations) > 0 {
		mmReserveFromStatus.mock.t.Fatalf("Some expectations are already set for the Messager.ReserveFromStatus method")
	}

	mmReserveFromStatus.mock.funcReserveFromStatus = f
	return mmReserveFromStatus.mock
}

// When sets expectation for the Messager.ReserveFromStatus which will trigger the result defined by the following
// Then helper
func (mmReserveFromStatus *mMessagerMockReserveFromStatus) When(n int, status string) *MessagerMockReserveFromStatusExpectation {
	if mmReserveFromStatus.mock.funcReserveFromStatus != nil {
		mmReserveFromStatus.mock.t.Fatalf("MessagerMock.ReserveFromStatus mock is already set by Set")
	}

	expectation := &MessagerMockReserveFromStatusExpectation{
		mock:   mmReserveFromStatus.mock,
		params: &MessagerMockReserveFromStatusParams{n, status},
	}
	mmReserveFromStatus.expectations = append(mmReserveFromStatus.expectations, expectation)
	return expectation
}

// Then sets up Messager.ReserveFromStatus return parameters for the expectation previously defined by the When method
func (e *MessagerMockReserveFromStatusExpectation) Then(ma1 []entity.Message, err error) *MessagerMock {
	e.results = &MessagerMockReserveFromStatusResults{ma1, err}
	return e.mock
}

// ReserveFromStatus implements app.Messager
func (mmReserveFromStatus *MessagerMock) ReserveFromStatus(n int, status string) (ma1 []entity.Message, err error) {
	mm_atomic.AddUint64(&mmReserveFromStatus.beforeReserveFromStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmReserveFromStatus.afterReserveFromStatusCounter, 1)

	if mmReserveFromStatus.inspectFuncReserveFromStatus != nil {
		mmReserveFromStatus.inspectFuncReserveFromStatus(n, status)
	}

	mm_params := &MessagerMockReserveFromStatusParams{n, status}

	// Record call args
	mmReserveFromStatus.ReserveFromStatusMock.mutex.Lock()
	mmReserveFromStatus.ReserveFromStatusMock.callArgs = append(mmReserveFromStatus.ReserveFromStatusMock.callArgs, mm_params)
	mmReserveFromStatus.ReserveFromStatusMock.mutex.Unlock()

	for _, e := range mmReserveFromStatus.ReserveFromStatusMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ma1, e.results.err
		}
	}

	if mmReserveFromStatus.ReserveFromStatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReserveFromStatus.ReserveFromStatusMock.defaultExpectation.Counter, 1)
		mm_want := mmReserveFromStatus.ReserveFromStatusMock.defaultExpectation.params
		mm_got := MessagerMockReserveFromStatusParams{n, status}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReserveFromStatus.t.Errorf("MessagerMock.ReserveFromStatus got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReserveFromStatus.ReserveFromStatusMock.defaultExpectation.results
		if mm_results == nil {
			mmReserveFromStatus.t.Fatal("No results are set for the MessagerMock.ReserveFromStatus")
		}
		return (*mm_results).ma1, (*mm_results).err
	}
	if mmReserveFromStatus.funcReserveFromStatus != nil {
		return mmReserveFromStatus.funcReserveFromStatus(n, status)
	}
	mmReserveFromStatus.t.Fatalf("Unexpected call to MessagerMock.ReserveFromStatus. %v %v", n, status)
	return
}

// ReserveFromStatusAfterCounter returns a count of finished MessagerMock.ReserveFromStatus invocations
func (mmReserveFromStatus *MessagerMock) ReserveFromStatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveFromStatus.afterReserveFromStatusCounter)
}

// ReserveFromStatusBeforeCounter returns a count of MessagerMock.ReserveFromStatus invocations
func (mmReserveFromStatus *MessagerMock) ReserveFromStatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserveFromStatus.beforeReserveFromStatusCounter)
}

// Calls returns a list of arguments used in each call to MessagerMock.ReserveFromStatus.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReserveFromStatus *mMessagerMockReserveFromStatus) Calls() []*MessagerMockReserveFromStatusParams {
	mmReserveFromStatus.mutex.RLock()

	argCopy := make([]*MessagerMockReserveFromStatusParams, len(mmReserveFromStatus.callArgs))
	copy(argCopy, mmReserveFromStatus.callArgs)

	mmReserveFromStatus.mutex.RUnlock()

	return argCopy
}

// MinimockReserveFromStatusDone returns true if the count of the ReserveFromStatus invocations corresponds
// the number of defined expectations
func (m *MessagerMock) MinimockReserveFromStatusDone() bool {
	for _, e := range m.ReserveFromStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveFromStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReserveFromStatusCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserveFromStatus != nil && mm_atomic.LoadUint64(&m.afterReserveFromStatusCounter) < 1 {
		return false
	}
	return true
}

// MinimockReserveFromStatusInspect logs each unmet expectation
func (m *MessagerMock) MinimockReserveFromStatusInspect() {
	for _, e := range m.ReserveFromStatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MessagerMock.ReserveFromStatus with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveFromStatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReserveFromStatusCounter) < 1 {
		if m.ReserveFromStatusMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MessagerMock.ReserveFromStatus")
		} else {
			m.t.Errorf("Expected call to MessagerMock.ReserveFromStatus with params: %#v", *m.ReserveFromStatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserveFromStatus != nil && mm_atomic.LoadUint64(&m.afterReserveFromStatusCounter) < 1 {
		m.t.Error("Expected call to MessagerMock.ReserveFromStatus")
	}
}

type mMessagerMockUpdate struct {
	mock               *MessagerMock
	defaultExpectation *MessagerMockUpdateExpectation
	expectations       []*MessagerMockUpdateExpectation

	callArgs []*MessagerMockUpdateParams
	mutex    sync.RWMutex
}

// MessagerMockUpdateExpectation specifies expectation struct of the Messager.Update
type MessagerMockUpdateExpectation struct {
	mock    *MessagerMock
	params  *MessagerMockUpdateParams
	results *MessagerMockUpdateResults
	Counter uint64
}

// MessagerMockUpdateParams contains parameters of the Messager.Update
type MessagerMockUpdateParams struct {
	m1 entity.Message
}

// MessagerMockUpdateResults contains results of the Messager.Update
type MessagerMockUpdateResults struct {
	m2  entity.Message
	err error
}

// Expect sets up expected params for Messager.Update
func (mmUpdate *mMessagerMockUpdate) Expect(m1 entity.Message) *mMessagerMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("MessagerMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &MessagerMockUpdateExpectation{}
	}

	mmUpdate.defaultExpectation.params = &MessagerMockUpdateParams{m1}
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the Messager.Update
func (mmUpdate *mMessagerMockUpdate) Inspect(f func(m1 entity.Message)) *mMessagerMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for MessagerMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by Messager.Update
func (mmUpdate *mMessagerMockUpdate) Return(m2 entity.Message, err error) *MessagerMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("MessagerMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &MessagerMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &MessagerMockUpdateResults{m2, err}
	return mmUpdate.mock
}

// Set uses given function f to mock the Messager.Update method
func (mmUpdate *mMessagerMockUpdate) Set(f func(m1 entity.Message) (m2 entity.Message, err error)) *MessagerMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the Messager.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the Messager.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	return mmUpdate.mock
}

// When sets expectation for the Messager.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mMessagerMockUpdate) When(m1 entity.Message) *MessagerMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("MessagerMock.Update mock is already set by Set")
	}

	expectation := &MessagerMockUpdateExpectation{
		mock:   mmUpdate.mock,
		params: &MessagerMockUpdateParams{m1},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up Messager.Update return parameters for the expectation previously defined by the When method
func (e *MessagerMockUpdateExpectation) Then(m2 entity.Message, err error) *MessagerMock {
	e.results = &MessagerMockUpdateResults{m2, err}
	return e.mock
}

// Update implements app.Messager
func (mmUpdate *MessagerMock) Update(m1 entity.Message) (m2 entity.Message, err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(m1)
	}

	mm_params := &MessagerMockUpdateParams{m1}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m2, e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_got := MessagerMockUpdateParams{m1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("MessagerMock.Update got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the MessagerMock.Update")
		}
		return (*mm_results).m2, (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(m1)
	}
	mmUpdate.t.Fatalf("Unexpected call to MessagerMock.Update. %v", m1)
	return
}

// UpdateAfterCounter returns a count of finished MessagerMock.Update invocations
func (mmUpdate *MessagerMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of MessagerMock.Update invocations
func (mmUpdate *MessagerMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to MessagerMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mMessagerMockUpdate) Calls() []*MessagerMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*MessagerMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *MessagerMock) MinimockUpdateDone() bool {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateInspect logs each unmet expectation
func (m *MessagerMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MessagerMock.Update with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MessagerMock.Update")
		} else {
			m.t.Errorf("Expected call to MessagerMock.Update with params: %#v", *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		m.t.Error("Expected call to MessagerMock.Update")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *MessagerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockLockedSpawnInspect()

		m.MinimockReserveFromStatusInspect()

		m.MinimockUpdateInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *MessagerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *MessagerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockLockedSpawnDone() &&
		m.MinimockReserveFromStatusDone() &&
		m.MinimockUpdateDone()
}
