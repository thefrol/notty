package mock

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i gitlab.com/thefrol/notty/internal/storage.SubscriptionRepository -o ./internal/service/mock/subscription_repo_mock.go -n SubscriptionRepositoryMock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.com/thefrol/notty/internal/entity"
)

// SubscriptionRepositoryMock implements service.SubscriptionRepository
type SubscriptionRepositoryMock struct {
	t minimock.Tester

	funcCreate          func(s1 entity.Subscription) (err error)
	inspectFuncCreate   func(s1 entity.Subscription)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mSubscriptionRepositoryMockCreate

	funcDelete          func(s1 string) (err error)
	inspectFuncDelete   func(s1 string)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mSubscriptionRepositoryMockDelete

	funcGet          func(s1 string) (s2 entity.Subscription, err error)
	inspectFuncGet   func(s1 string)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mSubscriptionRepositoryMockGet

	funcUpdate          func(s1 entity.Subscription) (err error)
	inspectFuncUpdate   func(s1 entity.Subscription)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mSubscriptionRepositoryMockUpdate
}

// NewSubscriptionRepositoryMock returns a mock for service.SubscriptionRepository
func NewSubscriptionRepositoryMock(t minimock.Tester) *SubscriptionRepositoryMock {
	m := &SubscriptionRepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mSubscriptionRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*SubscriptionRepositoryMockCreateParams{}

	m.DeleteMock = mSubscriptionRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*SubscriptionRepositoryMockDeleteParams{}

	m.GetMock = mSubscriptionRepositoryMockGet{mock: m}
	m.GetMock.callArgs = []*SubscriptionRepositoryMockGetParams{}

	m.UpdateMock = mSubscriptionRepositoryMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*SubscriptionRepositoryMockUpdateParams{}

	return m
}

type mSubscriptionRepositoryMockCreate struct {
	mock               *SubscriptionRepositoryMock
	defaultExpectation *SubscriptionRepositoryMockCreateExpectation
	expectations       []*SubscriptionRepositoryMockCreateExpectation

	callArgs []*SubscriptionRepositoryMockCreateParams
	mutex    sync.RWMutex
}

// SubscriptionRepositoryMockCreateExpectation specifies expectation struct of the SubscriptionRepository.Create
type SubscriptionRepositoryMockCreateExpectation struct {
	mock    *SubscriptionRepositoryMock
	params  *SubscriptionRepositoryMockCreateParams
	results *SubscriptionRepositoryMockCreateResults
	Counter uint64
}

// SubscriptionRepositoryMockCreateParams contains parameters of the SubscriptionRepository.Create
type SubscriptionRepositoryMockCreateParams struct {
	s1 entity.Subscription
}

// SubscriptionRepositoryMockCreateResults contains results of the SubscriptionRepository.Create
type SubscriptionRepositoryMockCreateResults struct {
	err error
}

// Expect sets up expected params for SubscriptionRepository.Create
func (mmCreate *mSubscriptionRepositoryMockCreate) Expect(s1 entity.Subscription) *mSubscriptionRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("SubscriptionRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &SubscriptionRepositoryMockCreateExpectation{}
	}

	mmCreate.defaultExpectation.params = &SubscriptionRepositoryMockCreateParams{s1}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the SubscriptionRepository.Create
func (mmCreate *mSubscriptionRepositoryMockCreate) Inspect(f func(s1 entity.Subscription)) *mSubscriptionRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for SubscriptionRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by SubscriptionRepository.Create
func (mmCreate *mSubscriptionRepositoryMockCreate) Return(err error) *SubscriptionRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("SubscriptionRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &SubscriptionRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &SubscriptionRepositoryMockCreateResults{err}
	return mmCreate.mock
}

// Set uses given function f to mock the SubscriptionRepository.Create method
func (mmCreate *mSubscriptionRepositoryMockCreate) Set(f func(s1 entity.Subscription) (err error)) *SubscriptionRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the SubscriptionRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the SubscriptionRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the SubscriptionRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mSubscriptionRepositoryMockCreate) When(s1 entity.Subscription) *SubscriptionRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("SubscriptionRepositoryMock.Create mock is already set by Set")
	}

	expectation := &SubscriptionRepositoryMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &SubscriptionRepositoryMockCreateParams{s1},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up SubscriptionRepository.Create return parameters for the expectation previously defined by the When method
func (e *SubscriptionRepositoryMockCreateExpectation) Then(err error) *SubscriptionRepositoryMock {
	e.results = &SubscriptionRepositoryMockCreateResults{err}
	return e.mock
}

// Create implements service.SubscriptionRepository
func (mmCreate *SubscriptionRepositoryMock) Create(s1 entity.Subscription) (err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(s1)
	}

	mm_params := &SubscriptionRepositoryMockCreateParams{s1}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_got := SubscriptionRepositoryMockCreateParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("SubscriptionRepositoryMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the SubscriptionRepositoryMock.Create")
		}
		return (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(s1)
	}
	mmCreate.t.Fatalf("Unexpected call to SubscriptionRepositoryMock.Create. %v", s1)
	return
}

// CreateAfterCounter returns a count of finished SubscriptionRepositoryMock.Create invocations
func (mmCreate *SubscriptionRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of SubscriptionRepositoryMock.Create invocations
func (mmCreate *SubscriptionRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to SubscriptionRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mSubscriptionRepositoryMockCreate) Calls() []*SubscriptionRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*SubscriptionRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *SubscriptionRepositoryMock) MinimockCreateDone() bool {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateInspect logs each unmet expectation
func (m *SubscriptionRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SubscriptionRepositoryMock.Create with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SubscriptionRepositoryMock.Create")
		} else {
			m.t.Errorf("Expected call to SubscriptionRepositoryMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		m.t.Error("Expected call to SubscriptionRepositoryMock.Create")
	}
}

type mSubscriptionRepositoryMockDelete struct {
	mock               *SubscriptionRepositoryMock
	defaultExpectation *SubscriptionRepositoryMockDeleteExpectation
	expectations       []*SubscriptionRepositoryMockDeleteExpectation

	callArgs []*SubscriptionRepositoryMockDeleteParams
	mutex    sync.RWMutex
}

// SubscriptionRepositoryMockDeleteExpectation specifies expectation struct of the SubscriptionRepository.Delete
type SubscriptionRepositoryMockDeleteExpectation struct {
	mock    *SubscriptionRepositoryMock
	params  *SubscriptionRepositoryMockDeleteParams
	results *SubscriptionRepositoryMockDeleteResults
	Counter uint64
}

// SubscriptionRepositoryMockDeleteParams contains parameters of the SubscriptionRepository.Delete
type SubscriptionRepositoryMockDeleteParams struct {
	s1 string
}

// SubscriptionRepositoryMockDeleteResults contains results of the SubscriptionRepository.Delete
type SubscriptionRepositoryMockDeleteResults struct {
	err error
}

// Expect sets up expected params for SubscriptionRepository.Delete
func (mmDelete *mSubscriptionRepositoryMockDelete) Expect(s1 string) *mSubscriptionRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("SubscriptionRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &SubscriptionRepositoryMockDeleteExpectation{}
	}

	mmDelete.defaultExpectation.params = &SubscriptionRepositoryMockDeleteParams{s1}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the SubscriptionRepository.Delete
func (mmDelete *mSubscriptionRepositoryMockDelete) Inspect(f func(s1 string)) *mSubscriptionRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for SubscriptionRepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by SubscriptionRepository.Delete
func (mmDelete *mSubscriptionRepositoryMockDelete) Return(err error) *SubscriptionRepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("SubscriptionRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &SubscriptionRepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &SubscriptionRepositoryMockDeleteResults{err}
	return mmDelete.mock
}

// Set uses given function f to mock the SubscriptionRepository.Delete method
func (mmDelete *mSubscriptionRepositoryMockDelete) Set(f func(s1 string) (err error)) *SubscriptionRepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the SubscriptionRepository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the SubscriptionRepository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the SubscriptionRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mSubscriptionRepositoryMockDelete) When(s1 string) *SubscriptionRepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("SubscriptionRepositoryMock.Delete mock is already set by Set")
	}

	expectation := &SubscriptionRepositoryMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &SubscriptionRepositoryMockDeleteParams{s1},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up SubscriptionRepository.Delete return parameters for the expectation previously defined by the When method
func (e *SubscriptionRepositoryMockDeleteExpectation) Then(err error) *SubscriptionRepositoryMock {
	e.results = &SubscriptionRepositoryMockDeleteResults{err}
	return e.mock
}

// Delete implements service.SubscriptionRepository
func (mmDelete *SubscriptionRepositoryMock) Delete(s1 string) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(s1)
	}

	mm_params := &SubscriptionRepositoryMockDeleteParams{s1}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_got := SubscriptionRepositoryMockDeleteParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("SubscriptionRepositoryMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the SubscriptionRepositoryMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(s1)
	}
	mmDelete.t.Fatalf("Unexpected call to SubscriptionRepositoryMock.Delete. %v", s1)
	return
}

// DeleteAfterCounter returns a count of finished SubscriptionRepositoryMock.Delete invocations
func (mmDelete *SubscriptionRepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of SubscriptionRepositoryMock.Delete invocations
func (mmDelete *SubscriptionRepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to SubscriptionRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mSubscriptionRepositoryMockDelete) Calls() []*SubscriptionRepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*SubscriptionRepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *SubscriptionRepositoryMock) MinimockDeleteDone() bool {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteInspect logs each unmet expectation
func (m *SubscriptionRepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SubscriptionRepositoryMock.Delete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SubscriptionRepositoryMock.Delete")
		} else {
			m.t.Errorf("Expected call to SubscriptionRepositoryMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		m.t.Error("Expected call to SubscriptionRepositoryMock.Delete")
	}
}

type mSubscriptionRepositoryMockGet struct {
	mock               *SubscriptionRepositoryMock
	defaultExpectation *SubscriptionRepositoryMockGetExpectation
	expectations       []*SubscriptionRepositoryMockGetExpectation

	callArgs []*SubscriptionRepositoryMockGetParams
	mutex    sync.RWMutex
}

// SubscriptionRepositoryMockGetExpectation specifies expectation struct of the SubscriptionRepository.Get
type SubscriptionRepositoryMockGetExpectation struct {
	mock    *SubscriptionRepositoryMock
	params  *SubscriptionRepositoryMockGetParams
	results *SubscriptionRepositoryMockGetResults
	Counter uint64
}

// SubscriptionRepositoryMockGetParams contains parameters of the SubscriptionRepository.Get
type SubscriptionRepositoryMockGetParams struct {
	s1 string
}

// SubscriptionRepositoryMockGetResults contains results of the SubscriptionRepository.Get
type SubscriptionRepositoryMockGetResults struct {
	s2  entity.Subscription
	err error
}

// Expect sets up expected params for SubscriptionRepository.Get
func (mmGet *mSubscriptionRepositoryMockGet) Expect(s1 string) *mSubscriptionRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("SubscriptionRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &SubscriptionRepositoryMockGetExpectation{}
	}

	mmGet.defaultExpectation.params = &SubscriptionRepositoryMockGetParams{s1}
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the SubscriptionRepository.Get
func (mmGet *mSubscriptionRepositoryMockGet) Inspect(f func(s1 string)) *mSubscriptionRepositoryMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for SubscriptionRepositoryMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by SubscriptionRepository.Get
func (mmGet *mSubscriptionRepositoryMockGet) Return(s2 entity.Subscription, err error) *SubscriptionRepositoryMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("SubscriptionRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &SubscriptionRepositoryMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &SubscriptionRepositoryMockGetResults{s2, err}
	return mmGet.mock
}

// Set uses given function f to mock the SubscriptionRepository.Get method
func (mmGet *mSubscriptionRepositoryMockGet) Set(f func(s1 string) (s2 entity.Subscription, err error)) *SubscriptionRepositoryMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the SubscriptionRepository.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the SubscriptionRepository.Get method")
	}

	mmGet.mock.funcGet = f
	return mmGet.mock
}

// When sets expectation for the SubscriptionRepository.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mSubscriptionRepositoryMockGet) When(s1 string) *SubscriptionRepositoryMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("SubscriptionRepositoryMock.Get mock is already set by Set")
	}

	expectation := &SubscriptionRepositoryMockGetExpectation{
		mock:   mmGet.mock,
		params: &SubscriptionRepositoryMockGetParams{s1},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up SubscriptionRepository.Get return parameters for the expectation previously defined by the When method
func (e *SubscriptionRepositoryMockGetExpectation) Then(s2 entity.Subscription, err error) *SubscriptionRepositoryMock {
	e.results = &SubscriptionRepositoryMockGetResults{s2, err}
	return e.mock
}

// Get implements service.SubscriptionRepository
func (mmGet *SubscriptionRepositoryMock) Get(s1 string) (s2 entity.Subscription, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(s1)
	}

	mm_params := &SubscriptionRepositoryMockGetParams{s1}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s2, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_got := SubscriptionRepositoryMockGetParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("SubscriptionRepositoryMock.Get got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the SubscriptionRepositoryMock.Get")
		}
		return (*mm_results).s2, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(s1)
	}
	mmGet.t.Fatalf("Unexpected call to SubscriptionRepositoryMock.Get. %v", s1)
	return
}

// GetAfterCounter returns a count of finished SubscriptionRepositoryMock.Get invocations
func (mmGet *SubscriptionRepositoryMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of SubscriptionRepositoryMock.Get invocations
func (mmGet *SubscriptionRepositoryMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to SubscriptionRepositoryMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mSubscriptionRepositoryMockGet) Calls() []*SubscriptionRepositoryMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*SubscriptionRepositoryMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *SubscriptionRepositoryMock) MinimockGetDone() bool {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetInspect logs each unmet expectation
func (m *SubscriptionRepositoryMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SubscriptionRepositoryMock.Get with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SubscriptionRepositoryMock.Get")
		} else {
			m.t.Errorf("Expected call to SubscriptionRepositoryMock.Get with params: %#v", *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		m.t.Error("Expected call to SubscriptionRepositoryMock.Get")
	}
}

type mSubscriptionRepositoryMockUpdate struct {
	mock               *SubscriptionRepositoryMock
	defaultExpectation *SubscriptionRepositoryMockUpdateExpectation
	expectations       []*SubscriptionRepositoryMockUpdateExpectation

	callArgs []*SubscriptionRepositoryMockUpdateParams
	mutex    sync.RWMutex
}

// SubscriptionRepositoryMockUpdateExpectation specifies expectation struct of the SubscriptionRepository.Update
type SubscriptionRepositoryMockUpdateExpectation struct {
	mock    *SubscriptionRepositoryMock
	params  *SubscriptionRepositoryMockUpdateParams
	results *SubscriptionRepositoryMockUpdateResults
	Counter uint64
}

// SubscriptionRepositoryMockUpdateParams contains parameters of the SubscriptionRepository.Update
type SubscriptionRepositoryMockUpdateParams struct {
	s1 entity.Subscription
}

// SubscriptionRepositoryMockUpdateResults contains results of the SubscriptionRepository.Update
type SubscriptionRepositoryMockUpdateResults struct {
	err error
}

// Expect sets up expected params for SubscriptionRepository.Update
func (mmUpdate *mSubscriptionRepositoryMockUpdate) Expect(s1 entity.Subscription) *mSubscriptionRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("SubscriptionRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &SubscriptionRepositoryMockUpdateExpectation{}
	}

	mmUpdate.defaultExpectation.params = &SubscriptionRepositoryMockUpdateParams{s1}
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the SubscriptionRepository.Update
func (mmUpdate *mSubscriptionRepositoryMockUpdate) Inspect(f func(s1 entity.Subscription)) *mSubscriptionRepositoryMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for SubscriptionRepositoryMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by SubscriptionRepository.Update
func (mmUpdate *mSubscriptionRepositoryMockUpdate) Return(err error) *SubscriptionRepositoryMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("SubscriptionRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &SubscriptionRepositoryMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &SubscriptionRepositoryMockUpdateResults{err}
	return mmUpdate.mock
}

// Set uses given function f to mock the SubscriptionRepository.Update method
func (mmUpdate *mSubscriptionRepositoryMockUpdate) Set(f func(s1 entity.Subscription) (err error)) *SubscriptionRepositoryMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the SubscriptionRepository.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the SubscriptionRepository.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	return mmUpdate.mock
}

// When sets expectation for the SubscriptionRepository.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mSubscriptionRepositoryMockUpdate) When(s1 entity.Subscription) *SubscriptionRepositoryMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("SubscriptionRepositoryMock.Update mock is already set by Set")
	}

	expectation := &SubscriptionRepositoryMockUpdateExpectation{
		mock:   mmUpdate.mock,
		params: &SubscriptionRepositoryMockUpdateParams{s1},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up SubscriptionRepository.Update return parameters for the expectation previously defined by the When method
func (e *SubscriptionRepositoryMockUpdateExpectation) Then(err error) *SubscriptionRepositoryMock {
	e.results = &SubscriptionRepositoryMockUpdateResults{err}
	return e.mock
}

// Update implements service.SubscriptionRepository
func (mmUpdate *SubscriptionRepositoryMock) Update(s1 entity.Subscription) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(s1)
	}

	mm_params := &SubscriptionRepositoryMockUpdateParams{s1}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_got := SubscriptionRepositoryMockUpdateParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("SubscriptionRepositoryMock.Update got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the SubscriptionRepositoryMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(s1)
	}
	mmUpdate.t.Fatalf("Unexpected call to SubscriptionRepositoryMock.Update. %v", s1)
	return
}

// UpdateAfterCounter returns a count of finished SubscriptionRepositoryMock.Update invocations
func (mmUpdate *SubscriptionRepositoryMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of SubscriptionRepositoryMock.Update invocations
func (mmUpdate *SubscriptionRepositoryMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to SubscriptionRepositoryMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mSubscriptionRepositoryMockUpdate) Calls() []*SubscriptionRepositoryMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*SubscriptionRepositoryMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *SubscriptionRepositoryMock) MinimockUpdateDone() bool {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateInspect logs each unmet expectation
func (m *SubscriptionRepositoryMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to SubscriptionRepositoryMock.Update with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to SubscriptionRepositoryMock.Update")
		} else {
			m.t.Errorf("Expected call to SubscriptionRepositoryMock.Update with params: %#v", *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		m.t.Error("Expected call to SubscriptionRepositoryMock.Update")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *SubscriptionRepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateInspect()

		m.MinimockDeleteInspect()

		m.MinimockGetInspect()

		m.MinimockUpdateInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *SubscriptionRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *SubscriptionRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetDone() &&
		m.MinimockUpdateDone()
}
