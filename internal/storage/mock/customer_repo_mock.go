package mock

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i gitlab.com/thefrol/notty/internal/storage.CustomerRepository -o ./internal/service/mock/customer_repo.go -n CustomerRepositoryMock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.com/thefrol/notty/internal/entity"
)

// CustomerRepositoryMock implements service.CustomerRepository
type CustomerRepositoryMock struct {
	t minimock.Tester

	funcCreate          func(c1 entity.Customer) (err error)
	inspectFuncCreate   func(c1 entity.Customer)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mCustomerRepositoryMockCreate

	funcDelete          func(s1 string) (err error)
	inspectFuncDelete   func(s1 string)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mCustomerRepositoryMockDelete

	funcGet          func(s1 string) (c1 entity.Customer, err error)
	inspectFuncGet   func(s1 string)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mCustomerRepositoryMockGet

	funcUpdate          func(c1 entity.Customer) (err error)
	inspectFuncUpdate   func(c1 entity.Customer)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mCustomerRepositoryMockUpdate
}

// NewCustomerRepositoryMock returns a mock for service.CustomerRepository
func NewCustomerRepositoryMock(t minimock.Tester) *CustomerRepositoryMock {
	m := &CustomerRepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mCustomerRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*CustomerRepositoryMockCreateParams{}

	m.DeleteMock = mCustomerRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*CustomerRepositoryMockDeleteParams{}

	m.GetMock = mCustomerRepositoryMockGet{mock: m}
	m.GetMock.callArgs = []*CustomerRepositoryMockGetParams{}

	m.UpdateMock = mCustomerRepositoryMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*CustomerRepositoryMockUpdateParams{}

	return m
}

type mCustomerRepositoryMockCreate struct {
	mock               *CustomerRepositoryMock
	defaultExpectation *CustomerRepositoryMockCreateExpectation
	expectations       []*CustomerRepositoryMockCreateExpectation

	callArgs []*CustomerRepositoryMockCreateParams
	mutex    sync.RWMutex
}

// CustomerRepositoryMockCreateExpectation specifies expectation struct of the CustomerRepository.Create
type CustomerRepositoryMockCreateExpectation struct {
	mock    *CustomerRepositoryMock
	params  *CustomerRepositoryMockCreateParams
	results *CustomerRepositoryMockCreateResults
	Counter uint64
}

// CustomerRepositoryMockCreateParams contains parameters of the CustomerRepository.Create
type CustomerRepositoryMockCreateParams struct {
	c1 entity.Customer
}

// CustomerRepositoryMockCreateResults contains results of the CustomerRepository.Create
type CustomerRepositoryMockCreateResults struct {
	err error
}

// Expect sets up expected params for CustomerRepository.Create
func (mmCreate *mCustomerRepositoryMockCreate) Expect(c1 entity.Customer) *mCustomerRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("CustomerRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &CustomerRepositoryMockCreateExpectation{}
	}

	mmCreate.defaultExpectation.params = &CustomerRepositoryMockCreateParams{c1}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the CustomerRepository.Create
func (mmCreate *mCustomerRepositoryMockCreate) Inspect(f func(c1 entity.Customer)) *mCustomerRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for CustomerRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by CustomerRepository.Create
func (mmCreate *mCustomerRepositoryMockCreate) Return(err error) *CustomerRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("CustomerRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &CustomerRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &CustomerRepositoryMockCreateResults{err}
	return mmCreate.mock
}

// Set uses given function f to mock the CustomerRepository.Create method
func (mmCreate *mCustomerRepositoryMockCreate) Set(f func(c1 entity.Customer) (err error)) *CustomerRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the CustomerRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the CustomerRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the CustomerRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mCustomerRepositoryMockCreate) When(c1 entity.Customer) *CustomerRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("CustomerRepositoryMock.Create mock is already set by Set")
	}

	expectation := &CustomerRepositoryMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &CustomerRepositoryMockCreateParams{c1},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up CustomerRepository.Create return parameters for the expectation previously defined by the When method
func (e *CustomerRepositoryMockCreateExpectation) Then(err error) *CustomerRepositoryMock {
	e.results = &CustomerRepositoryMockCreateResults{err}
	return e.mock
}

// Create implements service.CustomerRepository
func (mmCreate *CustomerRepositoryMock) Create(c1 entity.Customer) (err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(c1)
	}

	mm_params := &CustomerRepositoryMockCreateParams{c1}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_got := CustomerRepositoryMockCreateParams{c1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("CustomerRepositoryMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the CustomerRepositoryMock.Create")
		}
		return (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(c1)
	}
	mmCreate.t.Fatalf("Unexpected call to CustomerRepositoryMock.Create. %v", c1)
	return
}

// CreateAfterCounter returns a count of finished CustomerRepositoryMock.Create invocations
func (mmCreate *CustomerRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of CustomerRepositoryMock.Create invocations
func (mmCreate *CustomerRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to CustomerRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mCustomerRepositoryMockCreate) Calls() []*CustomerRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*CustomerRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *CustomerRepositoryMock) MinimockCreateDone() bool {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateInspect logs each unmet expectation
func (m *CustomerRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CustomerRepositoryMock.Create with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CustomerRepositoryMock.Create")
		} else {
			m.t.Errorf("Expected call to CustomerRepositoryMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		m.t.Error("Expected call to CustomerRepositoryMock.Create")
	}
}

type mCustomerRepositoryMockDelete struct {
	mock               *CustomerRepositoryMock
	defaultExpectation *CustomerRepositoryMockDeleteExpectation
	expectations       []*CustomerRepositoryMockDeleteExpectation

	callArgs []*CustomerRepositoryMockDeleteParams
	mutex    sync.RWMutex
}

// CustomerRepositoryMockDeleteExpectation specifies expectation struct of the CustomerRepository.Delete
type CustomerRepositoryMockDeleteExpectation struct {
	mock    *CustomerRepositoryMock
	params  *CustomerRepositoryMockDeleteParams
	results *CustomerRepositoryMockDeleteResults
	Counter uint64
}

// CustomerRepositoryMockDeleteParams contains parameters of the CustomerRepository.Delete
type CustomerRepositoryMockDeleteParams struct {
	s1 string
}

// CustomerRepositoryMockDeleteResults contains results of the CustomerRepository.Delete
type CustomerRepositoryMockDeleteResults struct {
	err error
}

// Expect sets up expected params for CustomerRepository.Delete
func (mmDelete *mCustomerRepositoryMockDelete) Expect(s1 string) *mCustomerRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("CustomerRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &CustomerRepositoryMockDeleteExpectation{}
	}

	mmDelete.defaultExpectation.params = &CustomerRepositoryMockDeleteParams{s1}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the CustomerRepository.Delete
func (mmDelete *mCustomerRepositoryMockDelete) Inspect(f func(s1 string)) *mCustomerRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for CustomerRepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by CustomerRepository.Delete
func (mmDelete *mCustomerRepositoryMockDelete) Return(err error) *CustomerRepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("CustomerRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &CustomerRepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &CustomerRepositoryMockDeleteResults{err}
	return mmDelete.mock
}

// Set uses given function f to mock the CustomerRepository.Delete method
func (mmDelete *mCustomerRepositoryMockDelete) Set(f func(s1 string) (err error)) *CustomerRepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the CustomerRepository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the CustomerRepository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the CustomerRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mCustomerRepositoryMockDelete) When(s1 string) *CustomerRepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("CustomerRepositoryMock.Delete mock is already set by Set")
	}

	expectation := &CustomerRepositoryMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &CustomerRepositoryMockDeleteParams{s1},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up CustomerRepository.Delete return parameters for the expectation previously defined by the When method
func (e *CustomerRepositoryMockDeleteExpectation) Then(err error) *CustomerRepositoryMock {
	e.results = &CustomerRepositoryMockDeleteResults{err}
	return e.mock
}

// Delete implements service.CustomerRepository
func (mmDelete *CustomerRepositoryMock) Delete(s1 string) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(s1)
	}

	mm_params := &CustomerRepositoryMockDeleteParams{s1}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_got := CustomerRepositoryMockDeleteParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("CustomerRepositoryMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the CustomerRepositoryMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(s1)
	}
	mmDelete.t.Fatalf("Unexpected call to CustomerRepositoryMock.Delete. %v", s1)
	return
}

// DeleteAfterCounter returns a count of finished CustomerRepositoryMock.Delete invocations
func (mmDelete *CustomerRepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of CustomerRepositoryMock.Delete invocations
func (mmDelete *CustomerRepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to CustomerRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mCustomerRepositoryMockDelete) Calls() []*CustomerRepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*CustomerRepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *CustomerRepositoryMock) MinimockDeleteDone() bool {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteInspect logs each unmet expectation
func (m *CustomerRepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CustomerRepositoryMock.Delete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CustomerRepositoryMock.Delete")
		} else {
			m.t.Errorf("Expected call to CustomerRepositoryMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		m.t.Error("Expected call to CustomerRepositoryMock.Delete")
	}
}

type mCustomerRepositoryMockGet struct {
	mock               *CustomerRepositoryMock
	defaultExpectation *CustomerRepositoryMockGetExpectation
	expectations       []*CustomerRepositoryMockGetExpectation

	callArgs []*CustomerRepositoryMockGetParams
	mutex    sync.RWMutex
}

// CustomerRepositoryMockGetExpectation specifies expectation struct of the CustomerRepository.Get
type CustomerRepositoryMockGetExpectation struct {
	mock    *CustomerRepositoryMock
	params  *CustomerRepositoryMockGetParams
	results *CustomerRepositoryMockGetResults
	Counter uint64
}

// CustomerRepositoryMockGetParams contains parameters of the CustomerRepository.Get
type CustomerRepositoryMockGetParams struct {
	s1 string
}

// CustomerRepositoryMockGetResults contains results of the CustomerRepository.Get
type CustomerRepositoryMockGetResults struct {
	c1  entity.Customer
	err error
}

// Expect sets up expected params for CustomerRepository.Get
func (mmGet *mCustomerRepositoryMockGet) Expect(s1 string) *mCustomerRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("CustomerRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &CustomerRepositoryMockGetExpectation{}
	}

	mmGet.defaultExpectation.params = &CustomerRepositoryMockGetParams{s1}
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the CustomerRepository.Get
func (mmGet *mCustomerRepositoryMockGet) Inspect(f func(s1 string)) *mCustomerRepositoryMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for CustomerRepositoryMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by CustomerRepository.Get
func (mmGet *mCustomerRepositoryMockGet) Return(c1 entity.Customer, err error) *CustomerRepositoryMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("CustomerRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &CustomerRepositoryMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &CustomerRepositoryMockGetResults{c1, err}
	return mmGet.mock
}

// Set uses given function f to mock the CustomerRepository.Get method
func (mmGet *mCustomerRepositoryMockGet) Set(f func(s1 string) (c1 entity.Customer, err error)) *CustomerRepositoryMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the CustomerRepository.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the CustomerRepository.Get method")
	}

	mmGet.mock.funcGet = f
	return mmGet.mock
}

// When sets expectation for the CustomerRepository.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mCustomerRepositoryMockGet) When(s1 string) *CustomerRepositoryMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("CustomerRepositoryMock.Get mock is already set by Set")
	}

	expectation := &CustomerRepositoryMockGetExpectation{
		mock:   mmGet.mock,
		params: &CustomerRepositoryMockGetParams{s1},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up CustomerRepository.Get return parameters for the expectation previously defined by the When method
func (e *CustomerRepositoryMockGetExpectation) Then(c1 entity.Customer, err error) *CustomerRepositoryMock {
	e.results = &CustomerRepositoryMockGetResults{c1, err}
	return e.mock
}

// Get implements service.CustomerRepository
func (mmGet *CustomerRepositoryMock) Get(s1 string) (c1 entity.Customer, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(s1)
	}

	mm_params := &CustomerRepositoryMockGetParams{s1}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_got := CustomerRepositoryMockGetParams{s1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("CustomerRepositoryMock.Get got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the CustomerRepositoryMock.Get")
		}
		return (*mm_results).c1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(s1)
	}
	mmGet.t.Fatalf("Unexpected call to CustomerRepositoryMock.Get. %v", s1)
	return
}

// GetAfterCounter returns a count of finished CustomerRepositoryMock.Get invocations
func (mmGet *CustomerRepositoryMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of CustomerRepositoryMock.Get invocations
func (mmGet *CustomerRepositoryMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to CustomerRepositoryMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mCustomerRepositoryMockGet) Calls() []*CustomerRepositoryMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*CustomerRepositoryMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *CustomerRepositoryMock) MinimockGetDone() bool {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetInspect logs each unmet expectation
func (m *CustomerRepositoryMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CustomerRepositoryMock.Get with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CustomerRepositoryMock.Get")
		} else {
			m.t.Errorf("Expected call to CustomerRepositoryMock.Get with params: %#v", *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		m.t.Error("Expected call to CustomerRepositoryMock.Get")
	}
}

type mCustomerRepositoryMockUpdate struct {
	mock               *CustomerRepositoryMock
	defaultExpectation *CustomerRepositoryMockUpdateExpectation
	expectations       []*CustomerRepositoryMockUpdateExpectation

	callArgs []*CustomerRepositoryMockUpdateParams
	mutex    sync.RWMutex
}

// CustomerRepositoryMockUpdateExpectation specifies expectation struct of the CustomerRepository.Update
type CustomerRepositoryMockUpdateExpectation struct {
	mock    *CustomerRepositoryMock
	params  *CustomerRepositoryMockUpdateParams
	results *CustomerRepositoryMockUpdateResults
	Counter uint64
}

// CustomerRepositoryMockUpdateParams contains parameters of the CustomerRepository.Update
type CustomerRepositoryMockUpdateParams struct {
	c1 entity.Customer
}

// CustomerRepositoryMockUpdateResults contains results of the CustomerRepository.Update
type CustomerRepositoryMockUpdateResults struct {
	err error
}

// Expect sets up expected params for CustomerRepository.Update
func (mmUpdate *mCustomerRepositoryMockUpdate) Expect(c1 entity.Customer) *mCustomerRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("CustomerRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &CustomerRepositoryMockUpdateExpectation{}
	}

	mmUpdate.defaultExpectation.params = &CustomerRepositoryMockUpdateParams{c1}
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the CustomerRepository.Update
func (mmUpdate *mCustomerRepositoryMockUpdate) Inspect(f func(c1 entity.Customer)) *mCustomerRepositoryMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for CustomerRepositoryMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by CustomerRepository.Update
func (mmUpdate *mCustomerRepositoryMockUpdate) Return(err error) *CustomerRepositoryMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("CustomerRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &CustomerRepositoryMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &CustomerRepositoryMockUpdateResults{err}
	return mmUpdate.mock
}

// Set uses given function f to mock the CustomerRepository.Update method
func (mmUpdate *mCustomerRepositoryMockUpdate) Set(f func(c1 entity.Customer) (err error)) *CustomerRepositoryMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the CustomerRepository.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the CustomerRepository.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	return mmUpdate.mock
}

// When sets expectation for the CustomerRepository.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mCustomerRepositoryMockUpdate) When(c1 entity.Customer) *CustomerRepositoryMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("CustomerRepositoryMock.Update mock is already set by Set")
	}

	expectation := &CustomerRepositoryMockUpdateExpectation{
		mock:   mmUpdate.mock,
		params: &CustomerRepositoryMockUpdateParams{c1},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up CustomerRepository.Update return parameters for the expectation previously defined by the When method
func (e *CustomerRepositoryMockUpdateExpectation) Then(err error) *CustomerRepositoryMock {
	e.results = &CustomerRepositoryMockUpdateResults{err}
	return e.mock
}

// Update implements service.CustomerRepository
func (mmUpdate *CustomerRepositoryMock) Update(c1 entity.Customer) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(c1)
	}

	mm_params := &CustomerRepositoryMockUpdateParams{c1}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_got := CustomerRepositoryMockUpdateParams{c1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("CustomerRepositoryMock.Update got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the CustomerRepositoryMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(c1)
	}
	mmUpdate.t.Fatalf("Unexpected call to CustomerRepositoryMock.Update. %v", c1)
	return
}

// UpdateAfterCounter returns a count of finished CustomerRepositoryMock.Update invocations
func (mmUpdate *CustomerRepositoryMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of CustomerRepositoryMock.Update invocations
func (mmUpdate *CustomerRepositoryMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to CustomerRepositoryMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mCustomerRepositoryMockUpdate) Calls() []*CustomerRepositoryMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*CustomerRepositoryMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *CustomerRepositoryMock) MinimockUpdateDone() bool {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateInspect logs each unmet expectation
func (m *CustomerRepositoryMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CustomerRepositoryMock.Update with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to CustomerRepositoryMock.Update")
		} else {
			m.t.Errorf("Expected call to CustomerRepositoryMock.Update with params: %#v", *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		m.t.Error("Expected call to CustomerRepositoryMock.Update")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CustomerRepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateInspect()

		m.MinimockDeleteInspect()

		m.MinimockGetInspect()

		m.MinimockUpdateInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CustomerRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CustomerRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetDone() &&
		m.MinimockUpdateDone()
}
